<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[利用WMI监视进程启动实现轻量级hook]]></title>
      <url>https://gksker.github.io/2016/11/01/%E5%88%A9%E7%94%A8WMI%E7%9B%91%E8%A7%86%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%AE%9E%E7%8E%B0%E8%BD%BB%E9%87%8F%E7%BA%A7hook/</url>
      <content type="text"><![CDATA[0x1 WMI简介 WMI是一项核心的Windows管理技术，WMI作为一种规范和基础结构，通过它可以访问、配置、管理和监视几乎所有的Windows资源，比如用户可以在远程计算机器上启动一个进程；设定一个在特定日期和时间运行的进程；远程启动计算机；获得本地或远程计算机的已安装程序列表；查询本地或远程计算机的Windows事件日志等等。 0x2 VC中使用WMI的几个步骤1) 首先初始化COM库，并设置并发模式：CoInitializeEx(https://msdn.microsoft.com/en-us/library/windows/desktop/ms695279(v=vs.85).aspx); 123456 HRESULT hRet = CoInitializeEx(NULL, COINIT_MULTITHREADED); if (FAILED(hRet)) &#123; return NULL; &#125; 2) 创建IWbemLocator对象 IWbemLocator是一个指向WMI的命名空间的IWbemServices对象，利用这个对象的方法对WMI进行操作; 1234567 IWbemLocator *pIWbemLocator = NULL;hRet = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&amp;pIWbemLocator);if (FAILED(hRet))&#123; CoUninitialize(); return NULL;&#125; 3) 连接到指定计算机上的Windows管理器： 123456789IWbemServices *pIWbemServices = NULL;bstr_t strNetwoekResource("ROOT\\CIMV2");hRet = pIWbemLocator-&gt;ConnectServer(strNetwoekResource, NULL, NULL, NULL, 0, NULL, NULL, &amp;pIWbemServices);if (FAILED(hRet))&#123; pIWbemLocator-&gt;Release(); CoUninitialize(); return NULL;&#125; 4) 为接口代理设置访问权限: 12345678hRet = CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);if (FAILED(hRet))&#123; pIWbemServices-&gt;Release(); pIWbemLocator-&gt;Release(); CoUninitialize(); return NULL;&#125; 5) 构建WQL语句 WQL就是WMI中的查询语句，WQL为WMI Query Language的简写，其语法和SQL语句很相似。本文中为了监视进程创建，应指定一个进程名，当WMI监视到该进程名，便通知程序，本例假设监视notepad进程，构建WQL语句如下： 12345bstr_t strQueryLanguage("WQL");string wql = "SELECT * FROM __InstanceCreationEvent WITHIN 1 WHERE TargetInstance ISA 'Win32_Process' AND (TargetInstance.Name = 'notepad.exe'";bstr_t strQuery(wsql.c_str());IEnumWbemClassObject *pIEnumWbemClassObject = NULL;hRet = pIWbemServices-&gt;ExecNotificationQuery(strQueryLanguage, strQuery, WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &amp;pIEnumWbemClassObject); 6) 开始监控 123456789do &#123; .... hRet = pTargetInstance-&gt;Get(L"ProcessID", 0, &amp;vtProcessID, NULL, NULL); int pid = vtProcessID.ulVal; ... &#125; while (TRUE); 0x3 其中的小问题 我们要实现hook，则必须在进程创建后kill掉该进程。到此便出现一个问题，如若该进程连带创建出一些同名子进程，程序的流程则不好控制。因为设计的流程是如果监视到该进程名创建，kill it，然后进行下一次检测。这样的话假若第一次kill的是子进程，那我们监视的进程则不会结束。 如果要达到我们的目的，则需要直接kill掉父进程，这样子进程也会因为父进程的死亡而死亡。 如何判断本次创建的进程是父进程呢，可以通过判断该进程的父进程是否为explorer.exe。 0x4 获取进程的父进程PID 有两种方法可以获取到进程的父进程PID： 一种通过用NtQueryInformationProcess获取PROCESS_BASIC_INFORMATION的结构体，其中有一个成员名为InheritedFromUniqueProcessId，便是查询进程的父进程PID； 另一种是通过查询进程快照，PROCESSENTRY32结构体中的成员变量th32ParentProcessID便为父进程PID。 第一种方法代码如下： 123456789101112131415161718 int GetParentProcessID(DWORD dwId) &#123; LONG status; DWORD dwParentPID = 0; HANDLE hProcess; PROCESS_BASIC_INFORMATION pbi; hProcess = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,dwId); if(!hProcess) return -1; status = NtQueryInformationProcess(hProcess,SystemBasicInformation,(PVOID)&amp;pbi,sizeof(PROCESS_BASIC_INFORMATION),NULL); if(!status) dwParentPID = pbi.InheritedFromUniqueProcessId; CloseHandle (hProcess); return dwParentPID; &#125; 第二种方法代码如下： 123456789101112131415161718192021222324 DWORD GetParentProcessID(DWORD dwId)&#123; PROCESSENTRY32 pe32 = &#123; 0 &#125;; pe32.dwSize = sizeof(pe32); HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); DWORD PID = 0; if (hSnapShot != 0 &amp;&amp; hSnapShot != INVALID_HANDLE_VALUE) &#123; BOOL bRet = Process32First(hSnapShot, &amp;pe32); while (bRet) &#123; if (pe32.th32ProcessID == dwId) &#123; PID = pe32.th32ParentProcessID; break; &#125; bRet = Process32Next(hSnapShot, &amp;pe32); &#125; CloseHandle(hSnapShot); &#125; return PID;&#125; 总结 本文中的hook其实不是真正意义上的hook，实际上没有拦截创建进程创建，而是通过监视进程创建后，结束掉后再做我们的工作再创建进程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[64位系统目录重定向]]></title>
      <url>https://gksker.github.io/2016/10/29/64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      <content type="text"><![CDATA[前段日子写代码时候遇到一个问题，在操作system32目录下的文件时候会返回错误：找不到文件的路径。当时一直没找到解决办法，最近在某个群里突然说到这个问题，有群里的朋友提出了些解决办法，虽然没有解决这个问题，但是通过这个问题，同事深入研究了下，最终解决了这个问题。我也从同事那了解到这个问题的解决办法。菜鸡的尴尬- -# 目录重定向 引发这个的问题主要原因就是由于在x64系统里面，存在两个目录：%systemroot%\system32和%systemroot%\sysWOW64，这两个目录一个是供64位程序使用，一个是供32位程序使用。如果一个32位程序试图向%systemroot%\system32操作，由于程序本身不是64位，其操作会被重定向到%systemroot%\sysWOW64目录下去，反之则不会。 所以如果使用如CopyFile、MoveFile、DeleteFile等等这类对文件进行操作的函数，其参数是指向%systemroot%\system32下的话，则需要考虑目录重定向的问题。 禁用重定向 微软提供了API，其可以在程序内实现对重定向的禁用：Wow64DisableWow64FsRedirection。 其官方解释为：禁用文件系统调用线程的重定向。重定向文件系统默认情况下是启用的。定义如下： BOOL WINAPI Wow64DisableWow64FsRedirection( _Out_ PVOID *OldValue ); Parameters OldValue [out] The WOW64 file system redirection value. The system uses this parameter to store information necessary to revert (re-enable) file system redirection. 更详细的内容请戳：https://msdn.microsoft.com/en-us/library/windows/desktop/aa365743(v=vs.85).aspx]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[imap登录邮箱与Oauth2.0认证]]></title>
      <url>https://gksker.github.io/2016/10/27/imap%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E4%B8%8EOauth2.0%E8%AE%A4%E8%AF%81/</url>
      <content type="text"><![CDATA[0x1 what’s IMAP? IMAP（Internet Mail Access Protocol，Internet邮件访问协议）以前称作交互邮件访问协议（Interactive Mail Access Protocol）。IMAP是斯坦福大学在1986年开发的一种邮件获取协议。它的主要作用是邮件客户端（例如MS Outlook Express)可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。当前的权威定义是RFC3501。IMAP协议运行在TCP/IP协议之上，使用的端口是143。它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。 0x2 RFC3501：IMAP的常用命令 IMAP命令主要参照RFC3501文档，文档有详细的命令说明，本文从编程的角度出发，介绍python的imaplib库进行IMAP常用命令的操作。本节以QQ邮箱为例，进行IMAP常用的常用操作。首先用帐号密码登录，与QQ邮箱的IMAP建立连接。 如果验证成功，打印login返回值有如下： 登录成功之后，就可以选择邮箱的文件夹，收件箱默认名称为“Inbox”，获取“Inbox”文件夹： 返回结果中，第二个元素是inbox文件夹邮件总数。如果不知道其他文件名，可用“list”命令查看，对应imaplib里的代码便是： 返回结果如下： 在选择一个文件夹后，便可以用search命令进行邮件查找，search命令可以根据搜索条件在活动状态的邮箱中搜索邮件，并返回邮件号。搜索的关键字有如下几种： ALL：邮件中所有邮件；ANDing的默认初始关键词。 ANSWERED：带有/Answered标记位的邮件。 BCC ：在信封结构的BCC域包含有指定字符串的邮件。 BEFORE ：实际日期（忽视时间和时区）早于指定日期的邮件。 BODY ：在邮件的主体域包含有指定字符串的邮件。 CC ：在信封结构的CC域包含有指定字符串的邮件。 DELETED：带有/Deleted标记位的邮件。 DRAFT：带有/Draft标记位的邮件。 FLAGGED：带有/Flagged标记位的邮件。 FROM ：在信封结构的FROM域包含有指定字符串的邮件。 HEADER ：带有一个含指定field-name（[RFC-2822]中定义）的头部、且在该头部（它跟在colon之后）的文本中包含指定字符串的邮 件。如果将要检索的字符串（参数中的string）长度为零，那么，它将匹配带有一个含指定field-name、内容可有可无的头部行的所有邮件。 KEYWORD ：带有指定关键词标记位的邮件。 LARGER ：带有一个[RFC-2822]（定义）的、大于指定字节数的大小的邮件。 NEW：带有/Recent标记位，但不带有/Seen标记的邮件。它在功能上等效于“(RECENT UNSEEN)”。 NOT ：不符合指定检索关键词的邮件。 OLD：不带有/Recent标记位的邮件。它在功能上等效于“NOT RECENT”（与“NOT NEW”相反）。 ON ：实际日期（忽视时间和时区）在指定日期的邮件。 OR ：符合任意一个检索关键词的邮件。 RECENT：带有/Recent标记位的邮件。 SEEN：带有/Seen标记位的邮件。 SENTBEFORE ：[RFC-2822]Date: header（忽视时间和时区）早于指定日期的邮件。 SENTON ：[RFC-2822]Date: header （忽视时间和时区）在指定日期的邮件。 SENTSINCE ：[RFC-2822]Date: header （忽视时间和时区）在指定日期或者晚于指定日期的邮件。 SINCE ：实际日期（忽视时间和时区）在指定日期或者晚于指定日期的邮件。 SMALLER ：带有一个[RFC-2822]的、小于指定字节数大小的邮件。 SUBJECT ：在信封结构的SUBJECT域含有指定字符串的邮件。 TEXT ：在邮件的头部或者主体含有指定字符串的邮件。 TO ：在信封结构的TO域含有指定字符串的邮件。 UID ：带有指定唯一标识符集相应的唯一标识符的邮件。序列集顺序排列是允许的。 UNANSWERED：不带有/Answered标记位的邮件。 UNDELETED：不带有/Deleted标记位的邮件。 UNDRAFT：不带有/Draft标记位的邮件。 UNFLAGGED：不带有/Flagged标记位的邮件。 UNKEYWORD ：不带有指定关键词标记位的邮件。 UNSEEN：不带有/Seen标记位的邮件。 Imaplib里的search方法有两个参数，第一个参数是charset的意思，填None表示用默认的ASCII，第二个参数为搜索条件，条件要用括号包含，可以同时指定多个条件,比如查找带有/seen标记并且日期在2016.8.3-2016.8.5的邮件（日期在搜索条件里需要用英文格式表示）： Search到符合条件的邮件后，可选择对应邮件号的邮件进行fetch操作。fetch命令用于读取邮件的文本信息，且仅用于显示的目的。包含两个参数，messageset：表示希望读取的邮件号列表，IAMP服务器邮箱中的每个邮件都有 一个唯一的ID标识，（邮件号列表参数可以是一个邮件号，也可以是由逗号分隔的多个邮件号，或者由冒号间隔的一个范围），IMAP服务器返回邮件号列表中 全部邮件的指定数据项内容。数据名参数确定能够被独立返回的邮件的一部分，下面我们看看各参数返回的邮件信息： ALL：只返回按照一定格式的邮件摘要，包括邮件标志、RFC822.SIZE、自身的时间和信封信息。IMAP客户机能够将标准邮件解析成这些信息并显示出来。 BODY：只返回邮件体文本格式和大小的摘要信息。IMAP客户机可以识别这些细腻，并向用户显示详细的关于邮件的信息。其实是一些非扩展的BODYSTRUCTURE的信息。 FAST：只返回邮件的一些摘要，包括邮件标志、RFC822.SIZE、和自身的时间。 FULL：同样的还是一些摘要信息，包括邮件标志、RFC822.SIZE、自身的时间和BODYSTRUCTURE的信息。 BODYSTRUCTUR： 是邮件的[MIME-IMB]的体结构。这是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段和[MIME-IMB]头信息得出来 的。包括的内容有：邮件正文的类型、字符集、编码方式等和各附件的类型、字符集、编码方式、文件名称等等。 ENVELOPE：信息的信封结构。是服务器通过解析[RFC-2822]头中的[MIME-IMB]各字段得出来的，默认各字段都是需要的。主要包括：自身的时间、附件数、收件人、发件人等。 FLAGS：此邮件的标志。 INTERNALDATE：自身的时间。 RFC822.SIZE：邮件的[RFC-2822]大小。 RFC822.HEADER：在功能上等同于BODY.PEEK[HEADER]。 RFC822：功能上等同于BODY[]。 RFC822.TEXT：功能上等同于BODY[TEXT] UID：返回邮件的UID号，UID号是唯一标识邮件的一个号码。 BODY[section] &lt;&gt;：返回邮件的中的某一指定部分，返回的部分用section来表示，section部分包含的信息通常是 代表某一部分的一个数字或者是下面的某一个部分：HEADER, HEADER.FIELDS, HEADER.FIELDS.NOT, MIME, and TEXT。如果section部分是空的话，那就代表返回全部的信息，包括头信息。 BODY[HEADER]返回完整的文件头信息。 BODY[HEADER.FIELDS ()]：在小括号里面可以指定返回的特定字段。 BODY[HEADER.FIELDS.NOT ()]：在小括号里面可以指定不需要返回的特定字段。 BODY[MIME]：返回邮件的[MIME-IMB]的头信息，在正常情况下跟BODY[HEADER]没有区别。 BODY[TEXT]：返回整个邮件体，这里的邮件体并不包括邮件头。 对于imaplib的fetch方法的两个参数分别是邮件号，取的内容。比如取对应邮件的时间，如下： 取邮件名： 这里存在一个编码问题，从服务器取回的文件名，都有如上述格式，给出编码类型和base64编码后的字符串，我们需要对该值进行处理，将字符串用base64解码后，再以GBK形式读出。此处可以用正则表达式，把字符串和编码类型分别读出来。 由于返回的字符串的编码类型不一样，具体情况还得具体解码。否则会显示不正常。 0x3 oAuth2.0 OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。OAuth2.0是OAuth协议的下一版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。 OAuth 2.0关注客户端开发者的简易性。要么通过组织在资源拥有者和HTTP服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。2012年10月，OAuth 2.0协议正式发布为RFC6749[1]。 对于google邮件使用imap的方式登录，其登录验证，不是通过SSL提交帐号密码验证，而是通过oAuth2.0认证后得到的token值进行登录验证。0x4 oAuth2.0认证授权过程OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。下图为RFC 6749的OAuth 2.0的运行流程： （A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 而以上几个步骤之中，步骤B是关键，同意给予客户端授权之后，客户端才可以获取token，进而通过token获取资源。下面介绍授权码模式进行授权。 0x5 oAuth2.0认证授权过程 授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。 （A）用户访问客户端，后者将前者导向认证服务器。 （B）用户选择是否给予客户端授权。 （C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。 （D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。 （E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 下面是上面这些步骤所需要的参数。 A步骤中，客户端申请认证的URI，包含以下参数： response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项 redirect_uri：表示重定向URI，可选项 scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 C步骤中，服务器回应客户端的URI，包含以下参数： code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。 state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数： grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 code：表示上一步获得的授权码，必选项。 redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 client_id：表示客户端ID，必选项。 E步骤中，认证服务器发送的HTTP回复，包含以下参数： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 0x6 使用Oatuh2.0授权访问 如果需要获取access_token和refresh_token，需要通过以下几个步骤： 去google APIs console(https://console.devel opers.google.com/apis/library)创建一个项目。 为你的认证程序创建一个证书。然后就得到了Client ID和Client secret。 构建授权认证URL：根据google官方文档，授权的url为：https://accounts.google.com/o/oauth2/auth 并且至少要求带上4个参数:scope, redirect_uri, response_type, client_id。官方示例代码(https://github.com/google/gmail-oauth2-tools)：授权URL登录授权后，获取到authorization_code。 构建获取token的URL： https://accounts.google.com/o/oauth2/token需要以下几个参数：code,client_id,client_secret,redirect_uri,grant_type官方脚本代码如下：最后返回一个json数据，包含access_token,token_type,expires_in,refresh_token 当token时效到期后，可构建refresh token的url，官方代码如下：请求会返回一个包含access_token,token_type和expires_in的json数据： 0x7 使用token登录 获取到access_token后，我可以用这个token进行授权登录imap.gmail.com。安装谷歌官方文档对access_token进行处理，代码如下所示：再将auth_string作为验证参数进行登录：登录成功！]]></content>
    </entry>

    
  
  
</search>
